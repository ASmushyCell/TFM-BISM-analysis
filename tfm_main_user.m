%% THIS IS A THE MAIN CODE TO DO TFM/BISM ANALYSIS
% The last implementation of this code with all the comments was done by Lucas Anger in october 2025, 
% Ladoux-Mège Lab, Institut Jacques Monod, Paris, France 

% The current implementation of this code is the result of combined efforts by 
% Vincent Nier, Joseph d’Allesandro, Benoît Ladoux, Lucas Anger, and possibly others. 
% Not all modifications could be fully tracked over time as tracing every change is basically doing internal lab archeology.

% To use please cite the two following papers: 
% - Nier et al, Inference of internal stress in a cell monolayer, Biophysical journal (2016)
% - Anger et al, Tissue stress measurements with Bayesian Inversion Stress Microscopy, EPJE (2026)

% -------------------------------------------------------------------------
% Code requirements and assumptions:
%
% This script relies on several conditions to function correctly:
% - The functions `BISM.m`, `getstressdirector_inv.m`, the `200colorbar` package, and `progressbar.m`
%   must be added to your MATLAB path.
% - Your current working directory must be set to a dataset folder structured as follows:
%       (folder) Input/
%           ├── Cells.tif
%           ├── Ref.tif
%           └── WithCells.tif
% -------------------------------------------------------------------------

clear all;
close all;
clc;

% -------------------------------------------------------------------------

% From here, run PIV analysis on the beads:
% 1. Launch the `PIVlab_App` to perform the analysis.
% 2. At the end of this step, a `PIVlab.m` workspace should be created 
%    in your current folder.
% 3. Once the analysis is complete, you can proceed to the next section.

% Note: This code is not intended to be executed all at once, but rather section by section.
% Some sections may require significant processing time. 
% Running the code step by step is generally advisable in MATLAB, as it makes it easier to identify and troubleshoot errors during execution.

%% Initialization

% Here is parameters you can change ; beside this section, you should not need to touch anything 
% -------------------------------------------------------------------------

time_frame = 15; % amount of time between each frame, in minutes  
pixel_dist= 0.64; %how much µm in one pixel in your image

name_piv = "PIVlab.mat"; %this should be generated by PIVLab, it's the name of the file you took from PIVlab
name_img = 'brightfield.tif'; %name of your brightfield image with cells

%soft material properties 
young = 15*1e3; %module de young in Pa, the stiffness of your elastomer
poisson = 0.5; %poisson ratio, always assume that it's incompressible so let it at 0.5

%%%%this matter only if you want to compute lambda again%%%
%if you don't care for it let it at 1
flag_lamba = 0; %if you let it at zero lambda to compute the stress will have a value of 10-6 (usual value if our lab paper)

% this a parameter for the stress, if you don't know let it at 0 ; basically it imposes a zero stress condition 
% on the edge of the image if confined case
boundary = 1; %% Boundary condition confined = 1, unconfined =0;

%FTTC macro ; this part is basically allowing Matlab to call FIJI by itself

fijiPath = 'C:\Users\Utilisateur\Desktop\Fiji.app\ImageJ-win64.exe';  % path to your fiji executable
macroPath = 'Z:\EPJE\code\TFM_analysis\macro_fiji\LoopFTTC.ijm'; %path to the LoopFTTC macro 

% -------------------------------------------------------------------------
% ----- FROM HERE DONT TOUCH ----------------------------------------------

load(name_piv, 'x', 'y', 'u_filtered', 'v_filtered');
Numframes=size(x,1); % get the number of frame 
xrange=size(x{1,1},2); % get the size on x axis of a given frame of piv
yrange=size(x{1,1},1); % get the size on y axis of a given frame of piv
nby = size(imread(name_img,1),1); % get the size on y axis of the true img
nbx = size(imread(name_img,1),2); % get the size on y axis of the true img


%% COMPUTE THE TRACTION FORCE FIELD ; FTTC PART
% Convert data to the format for FTTC 
% -------------------------------------------------------------------------

mkdir Output\FTTC_Output
cd Output\FTTC_Output

progressbar('Conversion in progress... ... ...');
for i=1:Numframes
    temp=[];
    for j=1:yrange
        for k=1:xrange
            temp=[temp;[x{i,1}(j,k),y{i,1}(j,k),u_filtered{i,1}(j,k),v_filtered{i,1}(j,k)]];
        end
    end

    fileID = fopen(['PIV',num2str(i),'.txt'],'w');
    fprintf(fileID,'%6.0f %6.0f %6.12f %6.12f\n',temp');  %important to be temp'
    fclose(fileID);
    progressbar(i/Numframes);
end

   cd ../..

% -------------------------------------------------------------------------
% Run the macro LoopFTTC on FIJI, calling it from MatLab

path = pwd; path_doubled = strrep(path, '\', '\\');
argString = strcat('Nframes~',num2str(Numframes),';arg_fttc~pixel=', num2str(pixel_dist),...
    ' poisson=', num2str(poisson),' young''s=', num2str(young),' regularization=9e-10 plot=1000 plot=1000 select=[',path_doubled);

full_string = ['"', fijiPath, '" --ij2 --headless -macro "', macroPath, '" "', argString, '"'];
status = system(full_string);

if status == 0
    disp('Fiji macro completed successfully!');
else
    warning('Fiji macro returned an error.');
end

%clean variable of no more use 
clear path argString path_doubled full_string status fileID temp
% -------------------------------------------------------------------------

%% COMPUTE THE TRACTION FORCE FIELD ; FIELD PART
% Run after FTTC plugin, compute the traction force field 

x_TFM_tutorial=cell(Numframes,1);
y_TFM_tutorial=cell(Numframes,1);
TF_MartielOutput=cell(Numframes,1);
  
cd Output/FTTC_Output
% -------------------------------------------------------------------------
% IMPORT Traction data TXT FILE SEQUENCES
% -------------------------------------------------------------------------
     
for i=1:Numframes
    fileName = strcat('Traction_PIV',num2str(i),'.txt');   %%**
    TF_MartielOutput{i,1}=importdata(fileName);
    i
end
      
% make it into PIVlab-style output
    
xlist=sort(unique(TF_MartielOutput{1,1}(:,1)));
ylist=sort(unique(TF_MartielOutput{1,1}(:,2)));
Numxpt=size(xlist,1); Numypt=size(ylist,1);
x_TFM_tutorial{1,1}=[]; y_TFM_tutorial{1,1}=[];
          
for i=1:Numframes
    x_TFM{i,1}=repmat(xlist',Numypt,1);
    y_TFM{i,1}=repmat(ylist,1,Numxpt);
end

progressbar('Importation of FTTC result ... ... ...');   

for i=1:Numframes
    for j=1:Numypt
        for k=1:Numxpt
            temp=TF_MartielOutput{i,1};
            temp=temp(temp(:,1)==x_TFM{i,1}(j,k),:);
            temp=temp(temp(:,2)==y_TFM{i,1}(j,k),:);
            Tx{i,1}(j,k)=temp(1,3);
            Ty{i,1}(j,k)=temp(1,4);
        end
    end
     progressbar(i/Numframes);
end

% ------------------------------------------------------------------------- 
%compute the magnitude of traction force field + remove value on the edges
for i=1:Numframes
    Tx{i,1}(1,:)=NaN; Ty{i,1}(1,:)=NaN;
    Tx{i,1}(:,1)=NaN; Ty{i,1}(:,1)=NaN;
    Tx{i,1}(end,:)=NaN; Ty{i,1}(end,:)=NaN;
    Tx{i,1}(:,end)=NaN; Ty{i,1}(:,end)=NaN;

    T{i,1}=sqrt(Tx{i,1}.^2+Ty{i,1}.^2);  
end
cd ../..


%clean variable of no more use 
clear TF_MartielOutput temp Numypt xlist Numxpt ylist x_TFM_tutorial y_TFM_tutorial fileName x y u_filtered v_filtered 

%save everything in working matlab workplace
save('traction_force.mat','T','Tx','Ty','x_TFM','y_TFM');

ytemp=y_TFM{1,1}; %pos on x in the true image based on PIV analysis
xtemp=x_TFM{1,1}; %pos on y in the true image based on PIV analysis

%% Compute the stress tensor field using Bayesian Inversion Stress Microscopy 
%preparation and some pre-processing 
path = pwd;
Z_x=x_TFM{1,1}; % TFM x data 
Z_y=y_TFM{1,1}; % TFM y data 
Z=size(Z_x); % 2D size of traction field 

ymax_pix = Z_y(Z(1),1); ymin_pix = Z_y(1,1); %max and min y position  
xmax_pix = Z_x(1,Z(2)); xmin_pix = Z_x(1,1); %max and min x position   
traction_folder = [path '\Output\FTTC_Output\'];

for i=1:Numframes
    
    traction_name = ['Traction_PIV', num2str(i) '.txt'];
    mydata{i} = importdata([traction_folder traction_name]);
    
    Fx = reshape(mydata{i}(:,3),Z(2),Z(1));
    Fy = reshape(mydata{i}(:,4),Z(2),Z(1));
    
    forces.Tx = Fx';
    forces.Ty = Fy';
    eval(['frame_' num2str(i,'%03d') '= forces;']);

end

clear traction_folder traction_name Z Fx Fy;
cd Output
mkdir Stress
    save([path '\Output\Stress\tractionforce.mat']); Path =([path '\Output\Stress\']);
cd ..

% ------------------------------------------------------------------------- 
% Run the BISM

coeff=pixel_dist; 
KMIN=1;
if flag_lamba

    %in the case of computation of LAMBDA
    KMAX =10; %compute lambda on the first 10 frames 
    CYRILLE=2; % L-curve method to find the optimal L
    JEDI=boundary; %% Boundary condition confined =1, unconfined =0;
    BISM;
else
    LAMBDA = 10e-6; %cf Joseph and Fanny discussion ; based on most of our computations and papers 
end

%no need to save it
%     save([Path 'L-curve.mat'],'Lambda_Lcurve','DDL','SIG_NO','Lambda');
%     save([Path 'L-curve.mat'],'DDL','SIG_NO','Lambda');
%     keep('LAMBDA','Path','dx','overlap','Numframes');
% 
KMAX = Numframes;
CYRILLE = 3; % Real run
JEDI=boundary; %% Boundary condition 
BISM;

% ------------------------------------------------------------------------- 
% Save all the stress component of the stress tensor and compute all invariant 

stress_xx=stress.sxx';
stress_xy=stress.sxy';
stress_yy=stress.syy';

progressbar('hello i am doing the computing of stress invariant namely I1 and J2');

%to know more about stress invariant in 2D case : https://www.continuummechanics.org/principalstress.html
% I1 = isotropic stress ; the opposite of the pressure 
% J2 = anisotropic stress ; magnitude of stress applied in one direction 
% the next loop compute 2D invariant with an easy physical meaning, namely I1 and J2
for k=1:Numframes
    
    sigmaXX = stress_xx{k,1};
    sigmaXY = stress_xy{k,1};
    sigmaYY = stress_yy{k,1};

    [Ms, ms, xD, yD, mu, VM] = getstressdirector_inv(sigmaXX, sigmaYY, sigmaXY);
    
    stress_M{k,1} = Ms; %maximum principal stress
    stress_m{k,1} = ms; %minimum principal stress
    stress_iso{k,1} = (sigmaXX + sigmaYY)/2; %isotropic stress, also equal to (Ms + ms)/2
    stress_aniso{k,1} = mu; %anisotropic stress  equal to (Ms - ms)/2
    angle_stress_x{k,1} = xD; %cos of theta, theta being the principal stress direction
    angle_stress_y{k,1} = yD; %sin of theta, theta being the principal stress direction
    stress_VM{k,1} = VM; %von mises stress
    progressbar(k/Numframes);
end

save('stress_mean.mat', 'stress_xx', 'stress_xy', 'stress_yy', 'stress_iso',...
    'stress_M','stress_m','angle_stress_x','angle_stress_y', 'stress_aniso','stress_VM');
load('traction_force.mat','T', 'x_TFM', 'y_TFM');

% ------------------------------------------------------------------------- 
%clean variable of no more use 
clear sigmaXY sigmaYY sigmaXX ms Ms xD yD mu VM k i j 
clear JEDI CYRILLE KMAX KMIN coeff
clear R R2 R2x R2y Ninf mydata A alpha_xy Ay1 BC C d0 DDL
clear f ForceName forces fplot k0 k1 kM l LAMBDA mTx mTy mult N 
clear noise_value SIG_NO sigma_post_yy sigma_post_xx sigma_post_xy stress sxxm sxym syym Tinfx Tinfy 
clear vsigma_yy vsigma_yx vsigma_xy vsigma_xx vTy vTx 
clear vsigma_post_yy vsigma_post_yx vsigma_post_xy vsigma_post_xx sigma_post_obs 
clear x y xmax xmax_pix ymax_pix ymax xmin xmin_pix ymin ymin_pix xrange yrange
clear Z_x Z_y meth_Lambda


%% Note of ending 
% ------------------------------------------------------------------------- 
% From this point, the main analysis is complete. 
% You can now use the raw outputs from traction_force.mat and stress_mean.mat 
% for further analysis.
%
% The following sections allow you to visualize the evolution of the 
% standard parameters we typically examine in our lab during TFM analysis, 
% namely: T, sigma_iso, sigma_aniso, sigma_VM, and their average and 
% fluctuations over time.
%
% You will also find tools to plot the spatial evolution of each field as 
% an image stack. This can be useful to visually inspect what is actually 
% happening and how it compares to the behavior of your cells over time. 

%% Classical time variation 

% T : traction force magnitude, S_iso : isotropic stress
% S_aniso : anisotropic stress, S_VM : Von Mises stress 
% This section computes the first moment (mean) and the second central 
% moment (variance of the normalized distribution) of these variables.

% make the time in hour; 
time = (0:Numframes-1)*(time_frame/60);
% compute tract mean / iso std 

% compute iso mean / iso std
m_iso = squeeze(mean(cat(3,stress_iso{:}),[1 2],'omitnan'));
f_iso = squeeze(std(cat(3,stress_iso{:}),0,[1 2],'omitnan'));
% compute aniso mean / aniso std 
m_aniso = squeeze(mean(cat(3,stress_aniso{:}),[1 2],'omitnan'));
f_aniso = squeeze(std(cat(3,stress_aniso{:}),0,[1 2],'omitnan'));
% compute VM mean / VM std 
m_vm = squeeze(mean(cat(3,stress_VM{:}),[1 2],'omitnan'));
f_vm = squeeze(std(cat(3,stress_VM{:}),0,[1 2],'omitnan'));
% compute T mean / T std 
m_T = squeeze(mean(cat(3,T{:}),[1 2],'omitnan'));
f_T = squeeze(std(cat(3,T{:}),0,[1 2],'omitnan'));

save('parameter_stats.mat','m_T','f_T','f_vm','m_vm','f_aniso','m_aniso','f_iso','m_iso');

% ------------------------------------------------------------------------- 
f = figure; 
h=gca;
h.LineWidth =1.4; %can change = thickness of the square of the figure
axis padded;
hold on;

titles = {'Traction force magnitude [Pa]','Isotropic stress [Pa.µm]','Anisotropic stress [Pa.µm]','Von mises stress [Pa.µm]'};
t = tiledlayout(2,4, 'TileSpacing','compact', 'Padding','compact');

%average
nexttile; plot(time, m_T, 'LineWidth', 1.5); title(titles{1}); xlabel('Time [h]'); ylabel('Average'); % traction force
nexttile; plot(time, m_iso, 'LineWidth', 1.5); title(titles{2}); xlabel('Time [h]'); ylabel('Average'); % isotropic stress
nexttile; plot(time, m_aniso, 'LineWidth', 1.5); title(titles{3}); xlabel('Time [h]'); ylabel('Average'); % anisotropic
nexttile; plot(time, m_vm, 'LineWidth', 1.5); title(titles{4}); xlabel('Time [h]'); ylabel('Average'); % von mises stress 

% std 
nexttile; plot(time, f_T, 'LineWidth', 1.5); title(titles{1}); xlabel('Time [h]'); ylabel('Standard deviation'); % traction force
nexttile; plot(time, f_iso, 'LineWidth', 1.5); title(titles{2}); xlabel('Time [h]'); ylabel('Standard deviation'); % isotropic stress
nexttile; plot(time, f_aniso, 'LineWidth', 1.5); title(titles{3}); xlabel('Time [h]'); ylabel('Standard deviation'); % anisotropic
nexttile; plot(time, f_vm, 'LineWidth', 1.5); title(titles{4}); xlabel('Time [h]'); ylabel('Standard deviation'); % von mises stress 

% Optional: add an overall title for the figure
title(t, 'Summary of the TFM/BISM main parameters behavior in time');
f.WindowState = 'maximized';

%% Spatial vizualization + plot of various field 
%the next section allows to plot various parameters in space and in time
%all the plot will be staved in Output/ corresponding folder 

flag_test = 0; %this is a flag that allow you not to plot the whole field for each frame but rather, for only one frame 
% flag_test = 1 ; plot the frame number "frame" else plot all the frame and saved them 
frame = 1; %the frame you want to see, if flag_test is at zero, this don't matter 

name_img = "brightfield.tif"; %name of the brightfield image 
%this would also work with another field or channel of course but you might want to change the colormap

%Each the following can be skipped depending on what you want to plot or see
% ------------------------------------------------------------------------- 
%some initialization if not done before 

ytemp=y_TFM{1,1}; %pos on x in the true image based on PIV analysis
xtemp=x_TFM{1,1}; %pos on y in the true image based on PIV analysis

%% ISOTROPIC STRESS 

cmax = max(cat(3,stress_iso{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize 

figure;

if flag_test 

    field = interpn(ytemp(:,1),xtemp(1,:),stress_iso{frame,1},(1:nby)',(1:nbx)); 
    [C, qh] = contourf(stress_iso{frame,1}, 80);
    set(qh,'EdgeColor','none');
    colormap(flipud(slanCM('spectral',80)));
    shading flat;
    axis equal tight;
    colorbar;
    title('Isotropic inter-cellular stress (Pa.µm)');
    %set(gca,'clim',[-cmax cmax]);
    hold on;
    set(gca,'YDir','reverse');
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Stress\IsotropicStress
    for i=1:Numframes
 
        field = interpn(ytemp(:,1),xtemp(1,:),stress_iso{i,1},(1:nby)',(1:nbx));  
        [C, qh] = contourf(field, 80);
        set(qh,'EdgeColor','none');
        colormap(flipud(slanCM('spectral',80)));
        shading flat;
        axis equal tight;
        colorbar;
        title('Isotropic inter-cellular stress (Pa.µm)');
        set(gca,'clim',[-cmax cmax]);
        hold on;
        set(gca,'YDir','reverse');
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]);
        set(gcf, 'WindowState','maximized' );
        cd Output\Stress\IsotropicStress
            saveas(gcf,['StressOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end


%% ISOTROPIC STRESS WITH CELLS IN BACKGROUND 
n_iso = 30; %number of line (the more, the less you see)

figure;
cmax = max(cat(3,stress_iso{:}),[],'all','omitnan')/3; %this is to saturate the color map to better visualize 
if flag_test 

    ax1=axes;
    img = imread(name_img,frame); 
    I = imadjust(img);
    imagesc(ax1,imadjust(img)); 
    axis equal tight; hold on;

    field = interpn(ytemp(:,1),xtemp(1,:),stress_iso{frame,1},(1:nby)',(1:nbx));
    ax2 = axes;
    [C, qh] = contour(ax2,field,n_iso);
    
    set(qh,'LineWidth',1.3);
    colormap(ax2,flipud(slanCM('spectral',80)));
    shading flat;
    hold on;
    title(ax1,['Isotropic Stress (Pa.µm)']);
    linkaxes([ax1,ax2])
    ax2.Visible = 'off';
    ax2.XTick = []; ax1.XTick = [];
    ax2.YTick = []; ax1.YTick = [];
    ax2.YDir='reverse';
    caxis([-cmax cmax]);
    colormap(ax1,'gray');
    colorbar(ax2,'Position',[0.92,0.13,0.02,0.78],'AxisLocation','out');
    axis equal tight;
    set(gcf, 'WindowState','maximized');
else
    mkdir Output\Stress\IsotropicStressCells
    for i=1:Numframes
        ax1=axes;
        img = imread(name_img,i); 
        I = imadjust(img);
        imagesc(ax1,imadjust(img)); 
        axis equal tight; hold on;
    
        field = interpn(ytemp(:,1),xtemp(1,:),stress_iso{i,1},(1:nby)',(1:nbx));
        ax2 = axes;
        [C, qh] = contour(ax2,field,n_iso);
        
        set(qh,'LineWidth',1.3);
        colormap(ax2,flipud(slanCM('spectral',80)));
        shading flat;
        hold on;
        title(ax1,['Isotropic Stress (Pa.µm)']);
        linkaxes([ax1,ax2])
        ax2.Visible = 'off';
        ax2.XTick = []; ax1.XTick = [];
        ax2.YTick = []; ax1.YTick = [];
        ax2.YDir='reverse';
        caxis([-cmax cmax]);
        colormap(ax1,'gray');
        colorbar(ax2,'Position',[0.92,0.13,0.02,0.78],'AxisLocation','out');
        axis equal tight;
        set(gcf, 'WindowState','maximized');
        cd Output\Stress\IsotropicStressCells
            saveas(gcf,['StressOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..
    end
end
%% ANISOTROPIC STRESS 

cmax = max(cat(3,stress_aniso{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize 

figure;

if flag_test 

    field = interpn(ytemp(:,1),xtemp(1,:),stress_aniso{frame,1},(1:nby)',(1:nbx)); 
    [C, qh] = contourf(field, 80);
    set(qh,'EdgeColor','none');
    colormap(flipud(slanCM('YlGnBu',80)));
    shading flat;
    axis equal tight;
    colorbar;
    title('Anisotropic inter-cellular stress (Pa.µm)');
    set(gca,'clim',[0 cmax]);
    hold on;
    set(gca,'YDir','reverse');
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Stress\AnisotropicStress
    for i=1:Numframes
 
        field = interpn(ytemp(:,1),xtemp(1,:),stress_aniso{i,1},(1:nby)',(1:nbx)); 
        [C, qh] = contourf(field, 80);
        set(qh,'EdgeColor','none');
        colormap(flipud(slanCM('YlGnBu',80)));
        shading flat;
        axis equal tight;
        colorbar;
        title('Anisotropic inter-cellular stress (Pa.µm)');
        set(gca,'clim',[0 cmax]);
        hold on;
        set(gca,'YDir','reverse');
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
        set(gcf, 'WindowState','maximized');
        cd Output\Stress\AnisotropicStress
            saveas(gcf,['StressOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end


%% ANISOTROPIC STRESS WITH CELLS IN BACKGROUND 


n_aniso = 20; %number of line (the more, the less you see)

figure;
cmax = max(cat(3,stress_aniso{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize

if flag_test 

    ax1=axes;
    img = imread(name_img,frame); 
    I = imadjust(img);
    imagesc(ax1,imadjust(img)); 
    axis equal tight; hold on;

    field = interpn(ytemp(:,1),xtemp(1,:),stress_aniso{frame,1},(1:nby)',(1:nbx));
    ax2 = axes;
    [C, qh] = contour(ax2,field,n_aniso);
    
    set(qh,'LineWidth',1.3);
    colormap(ax2,flipud(slanCM('YlGnBu',80)));
    shading flat;
    hold on;
    title(ax1,['Anisotropic Stress (Pa.µm)']);
    linkaxes([ax1,ax2])
    ax2.Visible = 'off';
    ax2.XTick = []; ax1.XTick = [];
    ax2.YTick = []; ax1.YTick = [];
    ax2.YDir='reverse';
    caxis([0 cmax]);
    colormap(ax1,'gray');
    colorbar(ax2,'Position',[0.92,0.13,0.02,0.78],'AxisLocation','out');
    axis equal tight;
    set(gcf, 'WindowState','maximized');
else
    mkdir Output\Stress\AnisotropicStressCells
    for i=1:Numframes
        ax1=axes;
        img = imread(name_img,i); 
        I = imadjust(img);
        imagesc(ax1,imadjust(img)); 
        axis equal tight; hold on;
    
        field = interpn(ytemp(:,1),xtemp(1,:),stress_aniso{i,1},(1:nby)',(1:nbx));
        ax2 = axes;
        [C, qh] = contour(ax2,field,n_aniso);
        
        set(qh,'LineWidth',1.3);
        colormap(ax2,flipud(slanCM('YlGnBu',80)));
        shading flat;
        hold on;
        title(ax1,['Anisotropic Stress (Pa.µm)']);
        linkaxes([ax1,ax2])
        ax2.Visible = 'off';
        ax2.XTick = []; ax1.XTick = [];
        ax2.YTick = []; ax1.YTick = [];
        ax2.YDir='reverse';
        caxis([0 cmax]);
        colormap(ax1,'gray');
        colorbar(ax2,'Position',[0.92,0.13,0.02,0.78],'AxisLocation','out');
        axis equal tight;
        set(gcf, 'WindowState','maximized');
        cd Output\Stress\AnisotropicStressCells
            saveas(gcf,['StressOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..
    end
end

%% ANISOTROPIC STRESS WITH THE PRINCIPAL STRESS ORIENTATION 

cmax = max(cat(3,stress_aniso{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize 

figure;

if flag_test 
    ar = sqrt(3)*stress_aniso{frame,1}./stress_VM{frame,1}; %pseudo aspect ratio for the principal stress direction 
    xD = angle_stress_x{frame,1};
    yD = angle_stress_y{frame,1};

    field = interpn(ytemp(:,1),xtemp(1,:),stress_aniso{frame,1},(1:nby)',(1:nbx)); 
    [C, qh] = contourf(field, 80);
    set(qh,'EdgeColor','none');
    colormap(flipud(slanCM('YlGnBu',80)));
    shading flat;
    axis equal tight;
    colorbar;
    title('Anisotropic inter-cellular stress (Pa.µm)');
    set(gca,'clim',[0 cmax]);
    hold on;
    set(gca,'YDir','reverse');
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
    quiver(xtemp- 14*ar.*xD/2, ytemp- 14*ar.*yD/2, 14*ar.*xD, 14*ar.*yD, 'off', 'LineWidth', 2,'ShowArrowHead', 'Off','Color', '#ee4035');
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Stress\AnisotropicStressOri
    for i=1:Numframes
 
        ar = sqrt(3)*stress_aniso{i,1}./stress_VM{i,1}; %pseudo aspect ratio for the principal stress direction 
        xD = angle_stress_x{i,1};
        yD = angle_stress_y{i,1};
    
        field = interpn(ytemp(:,1),xtemp(1,:),stress_aniso{i,1},(1:nby)',(1:nbx)); 
        [C, qh] = contourf(field, 80);
        set(qh,'EdgeColor','none');
        colormap(flipud(slanCM('YlGnBu',80)));
        shading flat;
        axis equal tight;
        colorbar;
        title('Anisotropic inter-cellular stress (Pa.µm)');
        set(gca,'clim',[0 cmax]);
        hold on;
        set(gca,'YDir','reverse');
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
        quiver(xtemp- 14*ar.*xD/2, ytemp- 14*ar.*yD/2, 14*ar.*xD, 14*ar.*yD, 'off', 'LineWidth', 2,'ShowArrowHead', 'Off','Color', '#ee4035');
        set(gcf, 'WindowState','maximized');
        cd Output\Stress\AnisotropicStressOri
            saveas(gcf,['StressOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end

%% PRINCIPAL STRESS ORIENTATION WITH CELLS IN BACKGROUND 

figure;

if flag_test 
    ar = sqrt(3)*stress_aniso{frame,1}./stress_VM{frame,1}; %pseudo aspect ratio for the principal stress direction 
    xD = angle_stress_x{frame,1};
    yD = angle_stress_y{frame,1};
    
    img = imread(name_img,frame); 
    I = imadjust(img);
    h = imagesc(I); hold on;
    colormap(flipud(slanCM('greys',50)));
    axis equal tight;
    set(h,'alphadata',~isnan(I)); hold on;
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[],'Color','k');
    title('Principal stress direction');
    quiver(xtemp- 14*ar.*xD/2, ytemp- 14*ar.*yD/2, 14*ar.*xD, 14*ar.*yD, 'off', 'LineWidth', 2,'ShowArrowHead', 'Off','Color', '#ee4035');
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Stress\AnisotropicStressCellsOri
    for i=1:Numframes

        ar = sqrt(3)*stress_aniso{i,1}./stress_VM{i,1}; %pseudo aspect ratio for the principal stress direction 
        xD = angle_stress_x{i,1};
        yD = angle_stress_y{i,1};
        img = imread(name_img, i); 
        I = imadjust(img);
        h = imagesc(I); hold on;
        colormap(flipud(slanCM('greys',50)));
        axis equal tight;
        set(h,'alphadata',~isnan(I)); hold on;
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[],'Color','k');
        title('Principal stress direction');
        
        quiver(xtemp- 14*ar.*xD/2, ytemp- 14*ar.*yD/2, 14*ar.*xD, 14*ar.*yD, 'off', 'LineWidth', 2,'ShowArrowHead', 'Off','Color', '#ee4035');
        set(gcf, 'WindowState','maximized');
        cd Output\Stress\AnisotropicStressCellsOri
            saveas(gcf,['StressOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end


%% TRACTION FORCE MAGNITUDE 

cmax = max(cat(3,T{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize 

figure;

if flag_test 

    field = interpn(ytemp(:,1),xtemp(1,:),T{frame,1},(1:nby)',(1:nbx)); 
    [C, qh] = contourf(field, 40);
    set(qh,'EdgeColor','none');
    colormap(slanCM('parula',40));
    shading flat;
    axis equal tight;
    colorbar;
    title('Traction forces magnitude (Pa)');
    set(gca,'clim',[0 cmax]);
    hold on;
    set(gca,'YDir','reverse');
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Traction\TractionMagnitude
    for i=1:Numframes
 
        field = interpn(ytemp(:,1),xtemp(1,:),T{i,1},(1:nby)',(1:nbx)); 
        [C, qh] = contourf(field, 40);
        set(qh,'EdgeColor','none');
        colormap(slanCM('parula',40));
        shading flat;
        axis equal tight;
        colorbar;
        title('Traction forces magnitude (Pa)');
        set(gca,'clim',[0 cmax]);
        hold on;
        set(gca,'YDir','reverse');
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
        set(gcf, 'WindowState','maximized');
        cd Output\Traction\TractionMagnitude
            saveas(gcf,['TractOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end

%% TRACTION FORCE MAGNITUDE WITH CELLS IN BACKGROUND 

cmax = max(cat(3,T{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize 
n_tract = 20; %number of line (the more, the less you see)

figure;
cmax = max(cat(3,T{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize

if flag_test 
    ax1=axes;
    img = imread(name_img,frame); 
    I = imadjust(img);
    imagesc(ax1,imadjust(img)); 
    axis equal tight; hold on;

    field = interpn(ytemp(:,1),xtemp(1,:),T{frame,1},(1:nby)',(1:nbx));
    ax2 = axes;
    [C, qh] = contour(ax2,field,n_tract);
    
    set(qh,'LineWidth',1.3);
    colormap(ax2,slanCM('parula',80));
    shading flat;
    hold on;
    title(ax1,['Traction force field (Pa)']);
    linkaxes([ax1,ax2])
    ax2.Visible = 'off';
    ax2.XTick = []; ax1.XTick = [];
    ax2.YTick = []; ax1.YTick = [];
    ax2.YDir='reverse';
    caxis([0 cmax]);
    colormap(ax1,'gray');
    colorbar(ax2,'Position',[0.92,0.13,0.02,0.78],'AxisLocation','out');
    axis equal tight;
    set(gcf, 'WindowState','maximized');
else
    mkdir Output\Traction\TractionMagnitudeOri
    for i=1:Numframes
 
        ax1=axes;
        img = imread(name_img,i); 
        I = imadjust(img);
        imagesc(ax1,imadjust(img)); 
        axis equal tight; hold on;
    
        field = interpn(ytemp(:,1),xtemp(1,:),T{i,1},(1:nby)',(1:nbx));
        ax2 = axes;
        [C, qh] = contour(ax2,field,n_tract);
        
        set(qh,'LineWidth',1.3);
        colormap(ax2,slanCM('parula',80));
        shading flat;
        hold on;
        title(ax1,['Traction force field (Pa)']);
        linkaxes([ax1,ax2])
        ax2.Visible = 'off';
        ax2.XTick = []; ax1.XTick = [];
        ax2.YTick = []; ax1.YTick = [];
        ax2.YDir='reverse';
        caxis([0 cmax]);
        colormap(ax1,'gray');
        colorbar(ax2,'Position',[0.92,0.13,0.02,0.78],'AxisLocation','out');
        axis equal tight;
        set(gcf, 'WindowState','maximized');
        cd Output\Traction\TractionMagnitudeOri
            saveas(gcf,['TractOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end


%% TRACTION FORCE MAGNITUDE WITH CELLS IN BACKGROUND 

cmax = max(cat(3,T{:}),[],'all','omitnan')/2; %this is to saturate the color map to better visualize 

figure;

if flag_test 
    
    field = interpn(ytemp(:,1),xtemp(1,:),T{frame,1},(1:nby)',(1:nbx)); 
    [C, qh] = contourf(field, 80);
    set(qh,'EdgeColor','none');
    colormap(flipud(slanCM('parula',40)));
    shading flat;
    axis equal tight;
    colorbar;
    title('Traction forces magnitude (Pa)');
    set(gca,'clim',[0 cmax]);
    hold on;
    set(gca,'YDir','reverse');
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
    T_x = Tx{frame,1}; T_y = Ty{frame,1}; Tm = T{frame,1};
    quiver(xtemp - T_x./(2*Tm),ytemp - T_y./(2*Tm), T_x, T_y,'k','AutoScaleFactor',1.5, 'LineWidth',2);
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Traction\TractionMagnitudeOri
    for i=1:Numframes
    
        field = interpn(ytemp(:,1),xtemp(1,:),T{i,1},(1:nby)',(1:nbx)); 
        [C, qh] = contourf(field, 80);
        set(qh,'EdgeColor','none');
        colormap(slanCM('parula',40));
        shading flat;
        axis equal tight;
        colorbar;
        title('Traction forces magnitude (Pa)');
        set(gca,'clim',[0 cmax]);
        hold on;
        set(gca,'YDir','reverse');
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[]); 
        T_x = Tx{frame,1}; T_y = Ty{frame,1}; Tm = T{frame,1};
        quiver(xtemp - T_x./(2*Tm), ytemp - T_y./(2*Tm), T_x, T_y,'k','AutoScaleFactor',1.5, 'LineWidth',2);
        set(gcf, 'WindowState','maximized');
        cd Output\Traction\TractionMagnitudeOri
            saveas(gcf,['TractOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end

%% TRACTION FORCE ORIENTATION WITH CELLS IN BACKGROUND 

figure;

if flag_test 

    
    img = imread(name_img,frame); 
    I = imadjust(img);
    h = imagesc(I); hold on;
    colormap(flipud(slanCM('greys',50)));
    axis equal tight;
    set(h,'alphadata',~isnan(I)); hold on;
    set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[],'Color','k');
    title('Traction forces field (Pa)');
    T_x = Tx{frame,1}; T_y = Ty{frame,1}; Tm = T{frame,1};
    quiver(xtemp - T_x./(2*Tm),ytemp - T_y./(2*Tm), T_x, T_y,'r','AutoScaleFactor',1.5, 'LineWidth',2);
    set(gcf, 'WindowState','maximized');

else
    mkdir Output\Traction\TractionCellOri
    for i=1:Numframes
 
        img = imread(name_img, i); 
        I = imadjust(img);
        h = imagesc(I); hold on;
        colormap(flipud(slanCM('greys',50)));
        axis equal tight;
        set(h,'alphadata',~isnan(I)); hold on;
        set(gca,'XColor','none','yColor','none','xtick',[],'ytick',[],'Color','k');
        title('Traction forces field (Pa)');
        T_x = Tx{i,1}; T_y = Ty{i,1}; Tm = T{i,1};
        quiver(xtemp - T_x./(2*Tm),ytemp - T_y./(2*Tm), T_x, T_y,'r','AutoScaleFactor',1.5, 'LineWidth',2);
        set(gcf, 'WindowState','maximized');
        cd Output\Traction\TractionCellOri
            saveas(gcf,['TractOutput' num2str(i) '.tif']);
            close gcf
    
        cd ..\..\..

    end

end
